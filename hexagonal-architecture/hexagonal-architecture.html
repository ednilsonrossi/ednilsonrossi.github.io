<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pattern Ports and Adapters</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.min.css" rel="stylesheet" />
</head>

<body class="d-flex flex-column vh-100">

  <!-- Título fixo -->
  <header class="navbar navbar-dark bg-dark flex-shrink-0">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#sidebarCollapse"
        aria-controls="sidebarCollapse" aria-expanded="true" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <span class="navbar-brand mb-0 h1">Pattern Ports and Adapters (Arquitetura Hexagonal)</span>
    </div>
  </header>

  <div class="d-flex flex-grow-1 overflow-hidden">
    <!-- Sidebar visível por padrão -->
    <nav class="bg-dark text-white p-3 flex-shrink-0 collapse show" id="sidebarCollapse" style="width: 200px;">
      <ul class="nav flex-column">
        <li class="nav-item">
          <a class="nav-link text-white" href="#introducao">Introdução</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="#exemplo">Exemplo prático</a>
        </li>
        <li class="nav-item">
          <a class="nav-link text-white" href="#referencias">Referências</a>
        </li>
        <!--
        <li class="nav-item">
          <a class="btn btn-outline-light mt-3 w-100" href="https://linktr.ee/ednilsonrossi" target="_blank"
            rel="noopener noreferrer">Meu Linktree</a>
        </li>
      -->
      </ul>
      <div class="mt-auto text-center">
        <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">
          <img src="https://licensebuttons.net/l/by/4.0/88x31.png" alt="Licença Creative Commons BY"
            class="img-fluid my-2">
        </a>

      </div>
    </nav>

    <!-- Conteúdo rolável -->
    <main class="flex-grow-1 overflow-auto p-4">

      <div class="text-center mb-4">
        <h1 class="display-4">Pattern Ports and Adapters <br>(Arquitetura Hexagonal)</h1>
        <p class="lead">Ednilson Geraldo Rossi e Janaina Cintra Abib</p>
        <p class="lead">Publicado em julho de 2025.</p>
        <hr>
      </div>

      <p class="fst-italic text-end">Programe para interfaces, não para implementações.</p>

      <h2 id="introducao">Introdução</h2>
      <p>Iniciamos a discussão sobre Arquitetura Hexagonal destacando que ela não se configura, necessariamente, como
        uma arquitetura de software tradicional. Enquanto a arquitetura de software atua em um nível mais alto de
        abstração, a Arquitetura Hexagonal está relacionada ao nível de código-fonte. Trata-se, portanto, de um padrão
        de organização de código cujo objetivo é isolar a lógica de negócio. Essa interpretação fica evidente na
        publicação original de Alistair Cockburn <a href="#ref1">[1]</a>.</p>

      <h3>O que é Arquitetura Hexagonal?</h3>
      <p>A Arquitetura Hexagonal foi inicialmente denominada Padrão Portas e Adaptadores (<i>Ports and Adapters</i>) em
        uma publicação de Alistair Cockburn em 2005 <a href="#ref1">[1]</a>. O principal objetivo desse padrão é isolar
        a lógica de negócio (ou lógica de domínio) dos códigos de infraestrutura, como, por exemplo, a persistência em
        um banco de dados relacional. Marcos Valente <a href="#ref2">[2]</a> destaca que o padrão se assemelha à
        Arquitetura Limpa (<i>Clean Architecture</i>), mas sua ideia central é favorecer a reusabilidade de código, a
        alta coesão, o baixo acoplamento e a independência de tecnologia.</p>

      <div class="text-center my-4">
        <img src="images/portsandadapters.png" class="img-fluid" alt="Imagem do padrão portas e adaptadores.">
        <p class="mt-2 text-muted">Figura 1: Padrão Portas e Adaptadores</p>
      </div>

      <p>A Figura 1 apresenta a ideia central da Arquitetura Hexagonal. Há uma camada interna (o hexágono verde) que
        representa a lógica de negócio (Domínio da Aplicação), onde se encontram as classes de domínio e os casos de uso
        do sistema. Essa camada deve ser completamente independente de tecnologias ou dependências externas. Por
        exemplo, não cabe à lógica de negócio definir como persistir dados em um banco de dados relacional; essa
        responsabilidade é delegada a outra camada. O Domínio da Aplicação apenas solicita que o dado seja persistido,
        sem conhecer os detalhes dessa operação.</p>

      <p>Na figura, observam-se as "portas" de entrada e saída (I/O). É por meio dessas portas que o Domínio da
        Aplicação interage com elementos externos, viabilizando a comunicação com outras camadas. As portas são
        utilizadas pelos Adaptadores (o hegágono externo), que possuem dependências externas e de tecnologia, além de
        conhecerem as portas de entrada e saída do Domínio da Aplicação. Por sua vez, elementos tecnológicos como
        sistemas gerenciadores de banco de dados, aplicações web, sistemas de mensageria, aplicações móveis, entre
        outros, comunicam-se com os Adaptadores para solicitar ou fornecer algum serviço ao Domínio da Aplicação.</p>

      <p>Como o Domínio da Aplicação é agnóstico em relação a qualquer tecnologia ou dependência externa, essa camada
        não é afetada por alterações no ambiente e pode ser migrada para qualquer plataforma que siga as mesmas regras
        de negócio. Da mesma forma, qualquer mudança de tecnologia — por exemplo, a troca de persistência relacional por
        não relacional — não impacta a lógica de negócio, sendo necessário apenas criar um adaptador adequado à nova
        tecnologia de persistência.</p>

      <h3>Portas</h3>
      <p>As portas são as interfaces utilizadas para a comunicação com as classes do Domínio da Aplicação. Por sua vez,
        as portas não dependem de tecnologia, estando, por isso, definidas no hexágono interno.</p>

      <p>As <b>portas de entrada</b> são interfaces que viabilizam a comunicação do exterior para o interior do Domínio
        da Aplicação, ou seja, quando algum componente externo precisa que o domínio execute alguma ação. Dessa forma,
        pode-se dizer que as portas de entrada definem de maneira clara os serviços oferecidos pelo sistema.

      </p>
      <p>As <b>portas de saída</b> são interfaces utilizadas para a comunicação do interior do domínio para o exterior,
        ou seja, quando algum componente do domínio necessita de alguma ação externa, como por exemplo enviar uma
        mensagem à uma fila.</p>

      <h3>Adaptadores</h3>
      <p>Não é possível desenvolver um sistema sem utilizar alguma tecnologia existente no mundo exterior, seja de
        comunicação (REST, gRPC etc.), de persistência de dados (SQL, NoSQL etc.) ou de interação com o usuário (web,
        mobile etc.). Assim, os <b>adaptadores</b> são responsáveis por tratar tanto as requisições do ambiente externo
        quanto as demandas do Domínio da Aplicação. Eles atuam recebendo chamadas externas e encaminhando-as para os
        métodos adequados definidos nas portas de entrada. Da mesma forma, recebem chamadas do domínio, por meio das
        portas de saída, e as direcionam de forma adequada para sistemas externos. Pensando de maneira mais próxima ao
        código-fonte, pode-se dizer que os adaptadores correspondem às implementações concretas das portas (interfaces).
      </p>

      <h3>Princípio da Resposabilidade Única e a Separação de Interesse</h3>
      <p>É importante perceber que a essência da Arquitetura Hexagonal está fortemente relacionada ao <i>Single
          Responsibility Principle</i>, sugerido por Uncle Bob <a href="#ref3">[3]</a>, que define que <i>"um componente
          deve ter apenas uma razão para mudar"</i>. Isso significa, por exemplo, que se algum componente tecnológico do
        sistema for alterado, não é necessário se preocupar com o Domínio da Aplicação, já que ele é independente e
        possui um interesse distinto. Dessa forma, observam-se fatores essenciais da Engenharia de Software presentes na
        Arquitetura Hexagonal: alta coesão e baixo acoplamento.</p>

      <h3>Inversão de Controle (IoC)</h3>
      <p>Um princípio fundamental da Arquitetura Hexagonal é a Inversão de Controle (IoC, do inglês <i>Inversion of
          Control</i>), que inverte o fluxo de controle em relação aos modelos tradicionais, como a programação
        procedural. Com esse princípio, o software delega a outros componentes a execução de partes do fluxo. Martin
        Fowler <a href="#ref4">[4]</a> relembra que o IoC segue o <i>Hollywood Principle: "Don't call us, we'll call
          you"</i>. Isso ocorre porque as portas de entrada e saída precisam ser implementadas, e o fluxo de controle
        transita entre os adaptadores e o Domínio da Aplicação por meio dessas portas.</p>


      <h2 id="exemplo">Exemplo prático</h2>
      <p>Para ilustrar a Arquitetura Hexagonal, apresenta-se e discute-se o desenvolvimento de uma aplicação completa.
        Neste exemplo, são utilizados a linguagem de programação Java, o framework Spring e o banco de dados em memória
        H2. Contudo, destaca-se que o padrão Portas e Adaptadores é agnóstico em relação à tecnologia, ou seja, pode ser
        implementado em outras linguagens e plataformas.</p>

      <h3>Problema</h3>
      <p>O problema apresentado consiste na necessidade de criar um sistema gerenciador de tarefas. Cada tarefa possui
        um título e um estado atual. Os possíveis estados da tarefa são: pendente, em progresso, completa e cancelada.
        Como regra de negócio, define-se que uma tarefa pode mudar do estado pendente para em progresso e, de em
        progresso, para completa. Ou seja, a tarefa "sabe" qual é o seu estado e muda de estado quando solicitado.
        Também é possível solicitar, de forma direta, que uma tarefa seja marcada como completa ou cancelada.</p>

      <p>O sistema oferece as seguintes funcionalidades:</p>
      <ul>
        <li>Criar uma nova tarefa.</li>
        <li>Alterar o estado de uma tarefa.</li>
        <li>Indicar que uma tarefa foi concluída.</li>
        <li>Indicar que uma tarefa foi cancelada.</li>
        <li>Recuperar uma tarefa.</li>
        <li>Recuperar as tarefas não finalizadas (pendentes e em progresso).</li>
      </ul>

      <h3>Solução</h3>
      <p>Observa-se no problema que existe uma regra de negócio específica para a alteração dos estados de uma tarefa.
        Para a solução, é necessário um repositório de dados, que, em um primeiro momento, será implementado como uma
        lista encadeada em memória. Também é necessária uma forma de interação com o sistema; optou-se por desenvolver
        uma API REST, permitindo que a interação seja realizada por meio de chamadas HTTP. A Figura 2 apresenta a
        solução inicial proposta, estruturada segundo a Arquitetura Hexagonal.</p>

      <div class="text-center my-4">
        <img src="images/soluction1.png" class="img-fluid" alt="Arquitetura proposta para solução do problema.">
        <p class="mt-2 text-muted">Figura 2: Arquitetura proposta.</p>
      </div>

      <p>No hexágono interno são implementadas todas as regras de negócio, sem qualquer dependência de tecnologia. Como
        se optou pelo uso do framework Spring, deve-se garantir que essa dependência não seja embutida no Domínio da
        Aplicação, mantendo-o focado exclusivamente nas regras de negócio. Na figura, são apresentadas duas portas, que
        serão implementadas como <code>interfaces</code> na linguagem de programação. São elas:
        <code>TaskInputPort</code>, que representa a porta de entrada, e <code>TaskRepositoryPort</code>, que é a porta
        de saída responsável pela persistência dos dados da aplicação. Existem ainda dois adaptadores: o
        <code>ControllerAdapter</code>, que adapta as chamadas REST recebidas pela API para o domínio, e o
        <code>DataMemoryAdapter</code>, responsável pela persistência dos dados usando, nesta proposta, uma lista em
        memória.
      </p>

      <h3>Hands On</h3>
      <p>Como a proposta é a implementação usando o framework Spring, inicializou-se um projeto usando <a
          href="https://start.spring.io/">Spring Initializr</a> conforme apresenta a Figura 3. Após a criação do projeto
        o mesmo foi importado para o IDE.</p>

      <div class="text-center my-4">
        <img src="images/initializr.png" class="img-fluid"
          alt="Criação de projeto e indicação de dependências no Spring Initializr.">
        <p class="mt-2 text-muted">Figura 3: Criação do projeto Spring.</p>
      </div>

      <p>Inicialmente, é necessário analisar o Domínio da Aplicação e os casos de uso. Foi criado um pacote
        <code>core</code> para representar o hexágono interno, ou seja, o Domínio da Aplicação. Esse pacote possui, como
        subpacotes, <code>application</code>, que representa os serviços ou casos de uso da aplicação;
        <code>domain</code>, que inclui as classes que definem o domínio da aplicação; e <code>ports</code>, que contém
        as portas de entrada e saída do domínio. A Figura 4 apresenta a estrutura completa de pacotes da aplicação;
        contudo, nesta seção, o foco deve ser dado ao pacote <code>core</code>.
      </p>

      <div class="text-center my-4">
        <img src="images/pakages.png" class="img-fluid" alt="Pacotes da estrutura do projeto.">
        <p class="mt-2 text-muted">Figura 4: Estrutura de pacotes.</p>
      </div>

      <h4>Implementação do Domínio da Aplicação</h4>

      <p>Considerando conceitos do DDD (<i>Domain-Driven Design</i>), entende-se que as entidades devem ser
        identificáveis, ou seja, devem possuir um identificador único. Em nossa solução, existe apenas a entidade
        <code>Task</code> (tarefa), que possui os atributos <code>id</code>, <code>título</code> e <code>estado</code>.
        Abaixo, apresenta-se a definição dessa classe:
      </p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          Task.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.core.domain;

import java.util.Objects;

public class Task {
    private Long taskId;
    private String title;
    private Status status;

    public Task() {
        this.taskId = -1L;
        this.status = Status.PENDING;
    }

    public Task(String title) {
        this();
        this.title = title.toUpperCase();
    }

    public Task(String title, Status status) {
        this(title);
        this.status = status;
    }

    public Task(Long id, String title, Status status) {
        this(title, status);
        this.taskId = id;
    }

    public void changeTaskStatus() {
        status = status.next();
    }

    public void finishTask() {
        status = Status.COMPLETED;
    }

    public void cancelTask() {
        status = Status.CANCELED;
    }

    public void setTitle(String title) {
        this.title = title.toUpperCase();
    }

    public Long getId() {
        return taskId;
    }

    public String getTitle() {
        return title;
    }

    public Status getStatus() {
        return status;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return Objects.equals(taskId, task.taskId);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(taskId);
    }
}
        </code>
      </pre>
      </div>

      <p>Ao analisar a classe <code>Task</code>, observam-se três atributos: <code>taskId</code>, <code>title</code> e
        <code>status</code>. A regra de negócio está diretamente relacionada ao estado (<code>status</code>) da
        tarefa.
        Por essa razão, optou-se por implementar <code>Status</code> como um <i>enum</i>, visando à simplificação do
        exemplo; entretanto, poderia ter sido adotado o padrão de projeto <i>State</i> ou outra estratégia
        equivalente.
        A regra de negócio define que o estado da tarefa pode mudar de pendente para em progresso e de em progresso
        para
        concluída. Para atender a essa regra, foi implementado o método <code>changeTaskStatus()</code>. Outras duas
        regras de negócio permitem alterar a tarefa diretamente para concluída ou cancelá-la. Para isso, foram
        implementados os métodos <code>finishTask()</code> e <code>cancelTask()</code>. É importante observar que não
        existe um método <code>setStatus()</code>, uma vez que essa operação não faz parte da regra de negócio e o
        estado da tarefa não deve ser alterado de forma indiscriminada.
      </p>

      <p>Em seguida, analise o <i>enum</i> <code>Status</code>. Esse <i>enum</i> encapsula parte da regra de negócio,
        pois é ele que define qual será o próximo estado (<code>Status</code>) a ser aplicado.</p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          Status.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.core.domain;

public enum Status {
    PENDING(1),         // Tarefa criada, mas não iniciada
    IN_PROGRESS(2),     // Tarefa em andamento
    COMPLETED(3),       // Tarefa finalizada
    CANCELED(99);       // Tarefa cancelada

    private final int order;

    Status(int order) {
        this.order = order;
    }

    public int getOrder() {
        return order;
    }

    public Status next() {
        if (this == PENDING) {
            return IN_PROGRESS;
        } else if (this == IN_PROGRESS) {
            return COMPLETED;
        } else {
            return this;
        }
    }

    public static Status fromCode(int code) {
        for (Status s : Status.values()) {
            if (s.getOrder() == code) {
                return s;
            }
        }
        throw new IllegalArgumentException("Code invalid: " + code);
    }
}
        </code>
      </pre>
      </div>

      <p>Aqui está implementada parte do domínio da nossa aplicação, servindo como base para o restante do
        desenvolvimento. Observe que estamos desenvolvendo essas classes sem qualquer dependência de bibliotecas
        externas, como as do Spring. Também se optou por não incluir bibliotecas como o Lombok, já que o objetivo da
        Arquitetura Hexagonal é manter o núcleo (<i>core</i>) da aplicação livre de dependências. A seguir, vamos
        visualizar as portas de entrada e saída da aplicação. As portas são interfaces que descrevem quais métodos o
        núcleo da aplicação expõe para receber solicitações ou utiliza para solicitar ações externas.</p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          TaskInputPort.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.core.port.in;

import io.github.ednilsonrossi.hexagonal_todoapp.core.domain.Task;
import java.util.List;

public interface TaskInputPort {
    Task createTask(Task task);

    Task updateTask(Task task);

    Task changeTaskStatus(Task task);

    Task finishTask(Task task);

    Task cancelTask(Task task);

    Task getTask(Long id);

    List<Task> getPendingTask();

    List<Task> getPendingAndInProgressTask();
}
        </code>
      </pre>
      </div>


      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          TaskRepositoryPort.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.core.port.out;

import io.github.ednilsonrossi.hexagonal_todoapp.core.domain.Task;
import java.util.List;

public interface TaskRepositoryPort {

    Task save(Task task) throws IllegalArgumentException;

    Task update(Task task) throws IllegalArgumentException;

    Task get(Long id);

    List<Task> getAll();
}

        </code>
      </pre>
      </div>

      <p>Seguindo o estilo de código da Arquitetura Hexagonal, as portas estão localizadas <i>dentro</i> do núcleo
        (<i>core</i>) da aplicação. Neste caso, elas estão no pacote
        <code>io.github.ednilsonrossi.hexagonal_todoapp.core.port</code>. Agora, vamos concluir a implementação do
        Domínio da Aplicação, definindo os serviços fornecidos.
      </p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          TaskService.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.core.application;

import io.github.ednilsonrossi.hexagonal_todoapp.core.domain.Status;
import io.github.ednilsonrossi.hexagonal_todoapp.core.domain.Task;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.in.TaskInputPort;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.out.TaskRepositoryPort;

import java.util.List;
import java.util.stream.Collectors;

public class TaskService implements TaskInputPort {

    private final TaskRepositoryPort repository;

    public TaskService(TaskRepositoryPort taskRepositoryPort) {
        this.repository = taskRepositoryPort;
    }

    @Override
    public Task createTask(Task task) {
        return repository.save(task);
    }

    @Override
    public Task updateTask(Task task) {
        return repository.update(task);
    }

    @Override
    public Task changeTaskStatus(Task task) {
        task.changeTaskStatus();
        return repository.update(task);
    }

    @Override
    public Task finishTask(Task task) {
        task.finishTask();
        return repository.update(task);
    }

    @Override
    public Task cancelTask(Task task) {
        task.cancelTask();
        return repository.update(task);
    }

    @Override
    public Task getTask(Long id) {
        return repository.get(id);
    }

    @Override
    public List<Task> getPendingTask() {
        var all = repository.getAll();
        return all.stream()
                .filter(task -> task.getStatus() == Status.PENDING)
                .toList();
    }

    @Override
    public List<Task> getPendingAndInProgressTask() {
        var all = repository.getAll();
        return all.stream()
                .filter(task -> task.getStatus() == Status.PENDING || task.getStatus() == Status.IN_PROGRESS)
                .collect(Collectors.toList());
    }
}
        </code>
      </pre>
      </div>

      <p>Analisando a classe de serviço, observamos que ela implementa a porta de entrada da aplicação. Ou seja, a
        classe <code>TaskService</code> é a implementação concreta da nossa porta de entrada. Essa implementação possui
        dependência do repositório de tarefas; no entanto, perceba que o tipo do atributo <code>repository</code> é
        <code>TaskRepositoryPort</code>, ou seja, trata-se da interface que representa a porta de saída do Domínio da
        Aplicação. Quando for necessário utilizar os serviços de domínio, deve-se injetar a implementação concreta do
        repositório. Ainda assim, mantém-se um baixo acoplamento, já que a classe <code>TaskService</code> não conhece
        nenhum detalhe sobre a implementação concreta do repositório. É importante destacar que a classe de serviço
        também não possui dependências externas, utilizando apenas código Java e dependências internas do próprio
        domínio.
      </p>

      <h4>Implementação dos Adaptadores: Adapter de Saída para o repositório</h4>
      <p>Conforme indicado na proposta inicial, vamos implementar a persistência de dados em memória utilizando uma
        lista encadeada. Para isso, será utilizada a classe <code>LinkedList</code> da biblioteca
        <code>java.util</code>. Embora essa implementação não faça uso de dependências externas, poderíamos incluir
        dependências de tecnologia, já que estamos na camada de adaptadores, e essa camada pode ter dependências
        externas sem comprometer o núcleo da aplicação.
      </p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          TaskDataMemoryAdapter.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.adapter.repository;

import io.github.ednilsonrossi.hexagonal_todoapp.core.domain.Task;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.out.TaskRepositoryPort;
import io.github.ednilsonrossi.hexagonal_todoapp.exception.TaskNotFoundException;

import java.util.LinkedList;
import java.util.List;

public class TaskDataMemoryAdapter implements TaskRepositoryPort {
    private static Long lastId = 1L;
    private final List<Task> dataset;

    public TaskDataMemoryAdapter() {
        dataset = new LinkedList<>();
    }

    @Override
    public Task save(Task task) {
        if (task == null) {
            throw new IllegalArgumentException("DataMemoryStore: task is null.");
        }

        lastId = lastId + 1;
        var novel = new Task(lastId, task.getTitle(), task.getStatus());
        dataset.add(novel);
        return novel;
    }

    @Override
    public Task update(Task task) throws IllegalArgumentException, TaskNotFoundException {
        if (task == null) {
            throw new IllegalArgumentException("DataMemoryStore: task is null.");
        }

        Task inDataset = null;
        for (Task t : dataset) {
            if (t.equals(task)) {
                inDataset = t;
                break;
            }
        }
        if (inDataset == null) {
            throw new TaskNotFoundException(task.getId());
        }

        dataset.remove(inDataset);
        inDataset = new Task(task.getId(), task.getTitle(), task.getStatus());
        dataset.add(inDataset);
        return inDataset;
    }

    @Override
    public Task get(Long id) {
        return dataset.stream()
                .filter(task -> task.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    @Override
    public List<Task> getAll() {
        return List.copyOf(dataset);
    }
}
        </code>
      </pre>
      </div>

      <h4>Implementação dos Adaptadores: Adaptador de Entrada (API HTTP)</h4>
      <p>A seguir, apresentamos a implementação do adaptador responsável por realizar a entrada no sistema. Optou-se por
        implementar uma API REST para receber as chamadas e encaminhá-las de forma adequada. O primeiro ponto a ser
        observado é que esse adaptador utiliza dependências do framework Spring para o tratamento das requisições. Outra
        observação importante é que esse adaptador depende da porta de entrada para encaminhar as requisições. É
        importante destacar que o adaptador depende da porta de entrada, e não diretamente da implementação da classe
        <code>TaskService</code>. A injeção dessa dependência será realizada pelo Spring por meio de uma configuração
        específica, que será abordada mais adiante. Agora, basta analisar a implementação a seguir para compreender como
        as requisições transitam do adaptador para o Domínio da Aplicação.
      </p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          TodoappController.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.adapter.controller;

import io.github.ednilsonrossi.hexagonal_todoapp.core.domain.Task;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.in.TaskInputPort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("todo")
public class TodoappController {

    private final TaskInputPort inputPort;

    public TodoappController(TaskInputPort taskInputPort) {
        this.inputPort = taskInputPort;
    }

    @GetMapping
    public ResponseEntity check() {
        return ResponseEntity.ok("Working...");
    }

    @GetMapping("/pending")
    public ResponseEntity getPending() {
        return ResponseEntity.ok(inputPort.getPendingTask());
    }

    @GetMapping("/undone")
    public ResponseEntity getUndone() {
        return ResponseEntity.ok(inputPort.getPendingAndInProgressTask());
    }

    @GetMapping("/{id}")
    public ResponseEntity getTaskByID(@PathVariable Long id) {
        var task = inputPort.getTask(id);
        if (task == null) {
            return ResponseEntity.notFound().build();
        }

        return ResponseEntity.ok(task);
    }

    @PostMapping
    public ResponseEntity create(@RequestBody Task task) {
        var saved = inputPort.createTask(task);
        return ResponseEntity.ok(saved);
    }

    @PatchMapping("/{id}")
    public ResponseEntity changeTaskStatus(@PathVariable Long id) {
        var task = inputPort.getTask(id);
        if (task == null) {
            return ResponseEntity.notFound().build();
        }

        task = inputPort.changeTaskStatus(task);
        return ResponseEntity.ok(task);
    }

}
        </code>
      </pre>
      </div>

      <h4>Configurações e Injeção de Dependências</h4>
      <p>Neste ponto da implementação, você deve ter percebido que estão faltando dois elementos muito importantes no
        código: a chamada do construtor de <code>TaskService</code> e a chamada do construtor de
        <code>TodoappController</code>. Ou seja, ainda é necessário injetar os objetos <code>taskRepositoryPort</code> e
        <code>taskInputPort</code> para que tudo funcione corretamente.
      </p>
      <p>Para instanciar esses objetos e utilizá-los no projeto, vamos utilizar os <i>Beans</i> do framework Spring.
        Serão criadas duas classes de configuração: uma para instanciar a classe <code>TaskService</code> e outra para
        <code>TaskDataMemoryAdapter</code>. Com esses <i>Beans</i>, o Spring realizará a injeção de dependências
        automaticamente sempre que esses objetos forem necessários. A seguir, apresentamos as duas classes de
        configuração.
      </p>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          InputPortConfig.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.config;

import io.github.ednilsonrossi.hexagonal_todoapp.core.application.TaskService;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.in.TaskInputPort;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.out.TaskRepositoryPort;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class InputPortConfig {

    @Bean
    public TaskInputPort getTaskInputImpl(TaskRepositoryPort repositoryPort) {
        return new TaskService(repositoryPort);
    }
}
        </code>
      </pre>
      </div>

      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          RepositoryConfig.java
        </div>
        <pre>
        <code class="language-java">
package io.github.ednilsonrossi.hexagonal_todoapp.config;

import io.github.ednilsonrossi.hexagonal_todoapp.adapter.repository.TaskDataMemoryAdapter;
import io.github.ednilsonrossi.hexagonal_todoapp.core.port.out.TaskRepositoryPort;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RepositoryConfig {

    @Bean
    public TaskRepositoryPort getRepositoryImpl() {
        return new TaskDataMemoryAdapter();
    }

}
        </code>
      </pre>
      </div>

      <p>Pronto, o sistema está implementado e funcional. Basta realizar chamadas usando, por exemplo, o Postman, e toda
        a aplicação estará em funcionamento, com baixo acoplamento e com as regras de negócio livres de qualquer
        dependência externa.</p>

      <p>Perceba que podemos simplesmente copiar o pacote <code>core</code> para um projeto no Android, sem que seja
        necessária qualquer alteração no núcleo do sistema, sendo preciso apenas implementar os adaptadores específicos
        para aquela tecnologia. No entanto, talvez você ainda não esteja totalmente convencido da solução implementada
        até aqui, ou possa achar que o projeto ficou extenso. Por isso, vamos propor uma segunda solução: substituir a
        persistência em memória por uma implementação usando um banco de dados relacional.</p>

      <h3>Solução 2</h3>
      <p>O objetivo desta segunda solução é demonstrar que nossa aplicação pode integrar diferentes tecnologias sem que
        o Domínio da Aplicação sofra qualquer intervenção. Alterar a forma de persistência não impacta as regras de
        negócio, portanto o núcleo (<i>core</i>) da aplicação deve permanecer intacto. Isso é possível porque o
        <i>core</i> foi projetado para ser independente de tecnologia. Para simplificação, utilizaremos o banco de dados
        relacional H2 (em memória); porém, poderíamos ter escolhido um serviço de banco de dados como MySQL, Oracle,
        MongoDB ou qualquer outra forma de persistência. Para incluir ainda mais dependências tecnológicas na aplicação,
        utilizaremos a biblioteca JPA para realizar a persistência de dados.
      </p>

      <div class="text-center my-4">
        <img src="images/soluction2.png" class="img-fluid" alt="Proposta de solução usando banco de dados relacional.">
        <p class="mt-2 text-muted">Figura 5: Proposta de solução 2.</p>
      </div>

      <h4>Implementando persistência em banco de dados relacional</h4>
      <p>Como vamos implementar a persistência usando JPA, a primeira coisa que precisamos fazer é mapear uma entidade
        para ser persistida no banco. Nada mais simples do que acessar a classe <code>Task</code> e adicionar as
        anotações do JPA para indicar a tabela e os campos.</p>

      <p><b>ATENÇÃO:</b> Transformar a classe <code>Task</code> em uma entidade JPA significaria incluir uma dependência
        externa no Domínio da Aplicação, o que não é uma alternativa aceitável para nós.</p>
        
      <p>Para garantir a conformidade com a Arquitetura Hexagonal, teremos sim uma entidade JPA, mas ela estará
        localizada junto dos adaptadores, que podem depender de tecnologia. É importante perceber que uma entidade JPA
        não é o mesmo objeto manipulado pelo domínio, mesmo que os dados sejam semelhantes ou idênticos. A entidade tem
        o propósito único de representar uma tupla no banco de dados relacional, sem possuir qualquer regra de negócio
        associada a ela. A seguir, apresentamos a implementação da classe <code>TaskEntity</code>, que representa nossa
        entidade. Essa classe está implementada junto dos adaptadores.</p>


      <div class="border rounded mb-3">
        <div class="bg-light text-dark px-3 py-2 border-bottom">
          Arquivo.java
        </div>
        <pre>
        <code class="language-java">

        </code>
      </pre>
      </div>


      <h2 id="referencias">Referências</h2>
      <p id="ref1">[1] <a href="https://alistair.cockburn.us/hexagonal-architecture">The Hexagonal (Ports & Adapters)
          Architecture</a></p>
      <p id="ref2">[2] Marco Tulio Valente. Engenharia de Software Moderna: Princípios e Práticas para Desenvolvimento
        de Software com Produtividade, Editora: Independente, 2020. <a href="https://engsoftmoderna.info/">(versão
          aberta e gratuíta em HTML) </a></p>

      <p id="ref3">[3] MARTIN, Robert C. The Single Responsibility Principle. The Clean Code Blog, 08 maio 2014.
        Disponível em: <a
          href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html">https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html.</a>
      </p>

      <p id="ref4">[4] FOWLER, Martin. Inversion of Control. Disponível em: <a
          href="https://martinfowler.com/bliki/InversionOfControl.html">https://martinfowler.com/bliki/InversionOfControl.html.</a>
      </p>

    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-java.min.js"></script>


</body>

</html>